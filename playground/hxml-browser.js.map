{
  "version": 3,
  "sources": ["../src/utils/source-map.ts", "../src/constants.ts", "../src/utils/errors.ts", "../src/tokenizer.ts", "../src/parser.ts", "../src/utils/vlq.ts", "../src/utils/escape.ts", "../src/emitter.ts", "../src/validator.ts", "../src/converter.ts", "../src/index.ts"],
  "sourcesContent": ["/**\r\n * source-map.ts \u2014 Position tracking for the HXML tokenizer.\r\n *\r\n * Provides types for source positions / ranges and a SourceTracker utility\r\n * that maps byte offsets to line/column numbers via a pre-computed\r\n * line-start-offset table with O(log n) binary-search lookup.\r\n */\r\n\r\n// \u2500\u2500 Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n/** A single position in a source document. */\r\nexport interface SourcePosition {\r\n    /** 1-indexed line number. */\r\n    line: number;\r\n    /** 0-indexed column number. */\r\n    col: number;\r\n    /** 0-indexed byte offset from start of source. */\r\n    offset: number;\r\n}\r\n\r\n/** A range between two positions (inclusive start, exclusive end). */\r\nexport interface SourceRange {\r\n    start: SourcePosition;\r\n    end: SourcePosition;\r\n}\r\n\r\n// \u2500\u2500 SourceTracker \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n/**\r\n * Pre-computes an array of line-start offsets for a given source string\r\n * so that any byte offset can be resolved to { line, col, offset } in\r\n * O(log n) time via binary search.\r\n */\r\nexport class SourceTracker {\r\n    /** Byte offsets where each line begins (index 0 = line 1). */\r\n    private readonly lineStarts: number[];\r\n\r\n    constructor(private readonly source: string) {\r\n        this.lineStarts = [0]; // line 1 always starts at offset 0\r\n        for (let i = 0; i < source.length; i++) {\r\n            if (source[i] === '\\n') {\r\n                this.lineStarts.push(i + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Resolve an absolute byte offset to a SourcePosition. */\r\n    positionAt(offset: number): SourcePosition {\r\n        // Clamp to valid range\r\n        if (offset <= 0) return { line: 1, col: 0, offset: 0 };\r\n        if (offset >= this.source.length) {\r\n            offset = this.source.length;\r\n        }\r\n\r\n        // Binary search for the line containing this offset\r\n        let lo = 0;\r\n        let hi = this.lineStarts.length - 1;\r\n        while (lo < hi) {\r\n            const mid = (lo + hi + 1) >>> 1;\r\n            if (this.lineStarts[mid] <= offset) {\r\n                lo = mid;\r\n            } else {\r\n                hi = mid - 1;\r\n            }\r\n        }\r\n\r\n        return {\r\n            line: lo + 1, // 1-indexed\r\n            col: offset - this.lineStarts[lo], // 0-indexed\r\n            offset,\r\n        };\r\n    }\r\n\r\n    /** Convenience: build a SourceRange from two offsets. */\r\n    range(startOffset: number, endOffset: number): SourceRange {\r\n        return {\r\n            start: this.positionAt(startOffset),\r\n            end: this.positionAt(endOffset),\r\n        };\r\n    }\r\n}\r\n", "/**\r\n * constants.ts \u2014 HTML5 rule tables that drive HXML parsing.\r\n *\r\n * Derived from the HTML5 specification's \"optional tags\" section.\r\n */\r\n\r\n// \u2500\u2500 Void elements (never have children or closing tags) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport const HTML_VOID_ELEMENTS = new Set([\r\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',\r\n    'link', 'meta', 'param', 'source', 'track', 'wbr',\r\n]);\r\n\r\n// \u2500\u2500 Raw text elements (contents parsed as literal text) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport const HTML_RAW_TEXT_ELEMENTS = new Set([\r\n    'script', 'style', 'textarea', 'title',\r\n]);\r\n\r\n// \u2500\u2500 Elements whose closing tag is optional \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport const HTML_OMIT_CLOSE = new Set([\r\n    'p', 'li', 'dt', 'dd', 'option', 'optgroup',\r\n    'rb', 'rt', 'rtc', 'rp',\r\n    'td', 'th', 'tr', 'thead', 'tbody', 'tfoot',\r\n    'colgroup', 'caption',\r\n]);\r\n\r\n// \u2500\u2500 Auto-close-before rules \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n// Maps an element name to the set of element names whose opening tag causes\r\n// the first element to be implicitly closed.  E.g. opening a <p> while another\r\n// <p> is open \u2192 auto-close the first <p>.\r\n\r\nexport const HTML_AUTO_CLOSE_BEFORE: Record<string, Set<string>> = {\r\n    p: new Set([\r\n        'address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl',\r\n        'fieldset', 'figcaption', 'figure', 'footer', 'h1', 'h2', 'h3', 'h4',\r\n        'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre',\r\n        'section', 'summary', 'table', 'ul',\r\n    ]),\r\n    li: new Set(['li']),\r\n    dt: new Set(['dt', 'dd']),\r\n    dd: new Set(['dt', 'dd']),\r\n    td: new Set(['td', 'th']),\r\n    th: new Set(['td', 'th']),\r\n    tr: new Set(['tr']),\r\n    option: new Set(['option', 'optgroup']),\r\n    optgroup: new Set(['optgroup']),\r\n    rb: new Set(['rb', 'rt', 'rtc', 'rp']),\r\n    rt: new Set(['rb', 'rt', 'rtc', 'rp']),\r\n    rtc: new Set(['rb', 'rtc', 'rp']),\r\n    rp: new Set(['rb', 'rt', 'rtc', 'rp']),\r\n    thead: new Set(['tbody', 'tfoot']),\r\n    tbody: new Set(['tbody', 'tfoot']),\r\n    tfoot: new Set(['tbody']),\r\n    colgroup: new Set(['colgroup']),\r\n    caption: new Set(['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr']),\r\n    head: new Set(['body']),\r\n};\r\n\r\n// \u2500\u2500 Predeclared XML namespaces \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport const PREDECLARED_NAMESPACES: ReadonlyMap<string, string> = new Map([\r\n    ['xml', 'http://www.w3.org/XML/1998/namespace'],\r\n    ['xmlns', 'http://www.w3.org/2000/xmlns/'],\r\n]);\r\n\r\n// \u2500\u2500 Inline elements (do not trigger block layout) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport const HTML_INLINE_ELEMENTS = new Set([\r\n    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data',\r\n    'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'rp', 'rt', 'ruby',\r\n    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time',\r\n    'u', 'var', 'wbr', 'img', 'input',\r\n]);\r\n\r\n// \u2500\u2500 Foreign content namespace URIs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n// Maps namespace URIs to the HTML5 foreign content parent element name.\r\n\r\nexport const FOREIGN_CONTENT_NAMESPACES: Record<string, string> = {\r\n    'http://www.w3.org/2000/svg': 'svg',\r\n    'http://www.w3.org/1998/Math/MathML': 'math',\r\n};\r\n\r\n", "/**\r\n * errors.ts \u2014 Diagnostic types and factory helpers for HXML.\r\n *\r\n * Error code ranges:\r\n *   HXML001\u2013099  Tokenizer errors\r\n *   HXML100\u2013199  Parser errors\r\n *     HXML101  Unmatched closing tag\r\n *     HXML102  Unclosed XML element inside a closing tag\r\n *     HXML103  XML element never closed at EOF\r\n *     HXML104  Tag name contains more than one colon\r\n *   HXML200\u2013299  Validation errors\r\n *     HXML205  Duplicate namespace declaration on an element\r\n *   HXML300\u2013399  Warnings\r\n */\r\n\r\nimport type { SourceRange } from './source-map.js';\r\n\r\n// \u2500\u2500 Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport type DiagnosticSeverity = 'error' | 'warning';\r\n\r\nexport interface Diagnostic {\r\n    severity: DiagnosticSeverity;\r\n    /** e.g. \"HXML001\", \"HXML201\" */\r\n    code: string;\r\n    /** Human-readable description. */\r\n    message: string;\r\n    /** Source location of the problem. */\r\n    loc: SourceRange;\r\n    /** Optional suggestion for fixing the issue. */\r\n    hint?: string;\r\n}\r\n\r\n// \u2500\u2500 Factories \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport function makeError(\r\n    code: string,\r\n    message: string,\r\n    loc: SourceRange,\r\n    hint?: string,\r\n): Diagnostic {\r\n    return { severity: 'error', code, message, loc, hint };\r\n}\r\n\r\nexport function makeWarning(\r\n    code: string,\r\n    message: string,\r\n    loc: SourceRange,\r\n    hint?: string,\r\n): Diagnostic {\r\n    return { severity: 'warning', code, message, loc, hint };\r\n}\r\n\r\n// \u2500\u2500 Formatting \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n/**\r\n * Format a diagnostic for terminal output, matching the format in \u00A77.4:\r\n *\r\n *   file:14:5 error HXML201: message\r\n *     |\r\n *     | 14 |     <offending line>\r\n *     |\r\n *     hint: ...\r\n */\r\nexport function formatDiagnostic(\r\n    diag: Diagnostic,\r\n    filePath: string,\r\n    sourceLines: string[],\r\n): string {\r\n    const { severity, code, message, loc, hint } = diag;\r\n    const line = loc.start.line;\r\n    const col = loc.start.col;\r\n\r\n    let out = `${filePath}:${line}:${col} ${severity} ${code}: ${message}\\n`;\r\n    out += '  |\\n';\r\n\r\n    if (line >= 1 && line <= sourceLines.length) {\r\n        const sourceLine = sourceLines[line - 1];\r\n        out += `  | ${line} | ${sourceLine}\\n`;\r\n\r\n        // Underline the range on this line\r\n        const startCol = loc.start.col;\r\n        const endCol =\r\n            loc.end.line === loc.start.line\r\n                ? loc.end.col\r\n                : sourceLine.length;\r\n        const pad = ' '.repeat(String(line).length + 3 + startCol);\r\n        const underline = '^'.repeat(Math.max(1, endCol - startCol));\r\n        out += `  | ${pad}${underline}\\n`;\r\n    }\r\n\r\n    out += '  |\\n';\r\n    if (hint) {\r\n        out += `  hint: ${hint}\\n`;\r\n    }\r\n\r\n    return out;\r\n}\r\n", "/**\r\n * tokenizer.ts \u2014 Character stream \u2192 token stream for HXML.\r\n *\r\n * A hand-written state machine that reads the source string character by\r\n * character and emits a stream of tokens.  Tracks line, column, and byte\r\n * offset for every token via SourceTracker.\r\n *\r\n * The tokenizer is intentionally \"dumb\" \u2014 it does not know about HTML mode\r\n * vs XML mode and does not do tree construction.  The one exception is\r\n * raw text elements (script, style, textarea, title): after emitting an\r\n * OPEN_TAG for one of these, the tokenizer switches to raw-text mode and\r\n * consumes everything as a single TEXT token until the matching close tag.\r\n */\r\n\r\nimport { SourceTracker, type SourceRange } from './utils/source-map.js';\r\nimport { HTML_RAW_TEXT_ELEMENTS } from './constants.js';\r\nimport type { Diagnostic } from './utils/errors.js';\r\nimport { makeError } from './utils/errors.js';\r\n\r\n// \u2500\u2500 Token types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport interface TokenAttribute {\r\n    name: string;\r\n    value: string | null;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface TextToken {\r\n    type: 'TEXT';\r\n    value: string;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface OpenTagToken {\r\n    type: 'OPEN_TAG';\r\n    name: string;\r\n    attrs: TokenAttribute[];\r\n    selfClosing: boolean;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface CloseTagToken {\r\n    type: 'CLOSE_TAG';\r\n    name: string;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface CommentToken {\r\n    type: 'COMMENT';\r\n    value: string;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface CDataToken {\r\n    type: 'CDATA';\r\n    value: string;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface PIToken {\r\n    type: 'PI';\r\n    target: string;\r\n    data: string;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport interface DoctypeToken {\r\n    type: 'DOCTYPE';\r\n    value: string;\r\n    loc: SourceRange;\r\n}\r\n\r\nexport type Token =\r\n    | TextToken\r\n    | OpenTagToken\r\n    | CloseTagToken\r\n    | CommentToken\r\n    | CDataToken\r\n    | PIToken\r\n    | DoctypeToken;\r\n\r\n// \u2500\u2500 Tokenizer \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport class Tokenizer {\r\n    private pos = 0;\r\n    private readonly src: string;\r\n    private readonly tracker: SourceTracker;\r\n    readonly diagnostics: Diagnostic[] = [];\r\n\r\n    constructor(source: string) {\r\n        this.src = source;\r\n        this.tracker = new SourceTracker(source);\r\n    }\r\n\r\n    // \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    private eof(): boolean {\r\n        return this.pos >= this.src.length;\r\n    }\r\n\r\n    private peek(n = 0): string {\r\n        return this.src[this.pos + n] ?? '';\r\n    }\r\n\r\n    private consume(n = 1): string {\r\n        const s = this.src.slice(this.pos, this.pos + n);\r\n        this.pos += n;\r\n        return s;\r\n    }\r\n\r\n    private match(str: string): boolean {\r\n        return this.src.startsWith(str, this.pos);\r\n    }\r\n\r\n    private matchCI(str: string): boolean {\r\n        if (this.pos + str.length > this.src.length) return false;\r\n        for (let i = 0; i < str.length; i++) {\r\n            const a = this.src.charCodeAt(this.pos + i);\r\n            const b = str.charCodeAt(i);\r\n            // Fast case-insensitive compare: if not equal, try flipping bit 5\r\n            // (works for ASCII letters where 'a' ^ 'A' === 32)\r\n            if (a === b) continue;\r\n            // Check if both are ASCII letters and differ only by case\r\n            const aLower = a | 0x20;\r\n            const bLower = b | 0x20;\r\n            if (aLower !== bLower || aLower < 0x61 || aLower > 0x7A) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private skipWS(): void {\r\n        while (!this.eof()) {\r\n            const c = this.src.charCodeAt(this.pos);\r\n            // space, tab, LF, CR, FF\r\n            if (c !== 0x20 && c !== 0x09 && c !== 0x0A && c !== 0x0D && c !== 0x0C) break;\r\n            this.pos++;\r\n        }\r\n    }\r\n\r\n    private readUntil(terminator: string): string {\r\n        const i = this.src.indexOf(terminator, this.pos);\r\n        if (i < 0) {\r\n            const s = this.src.slice(this.pos);\r\n            this.pos = this.src.length;\r\n            return s;\r\n        }\r\n        const s = this.src.slice(this.pos, i);\r\n        this.pos = i + terminator.length;\r\n        return s;\r\n    }\r\n\r\n    private readWhile(fn: (ch: string) => boolean): string {\r\n        const start = this.pos;\r\n        while (!this.eof() && fn(this.src[this.pos])) {\r\n            this.pos++;\r\n        }\r\n        return this.src.slice(start, this.pos);\r\n    }\r\n\r\n    // \u2500\u2500 Attribute parsing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    private readAttrValue(): string {\r\n        const q = this.peek();\r\n        if (q === '\"' || q === \"'\") {\r\n            const quoteStart = this.pos;\r\n            this.pos++; // opening quote\r\n            // Read until closing quote, but stop at newlines to avoid\r\n            // consuming the entire document on an unterminated attribute.\r\n            const valStart = this.pos;\r\n            while (!this.eof()) {\r\n                const ch = this.src[this.pos];\r\n                if (ch === q) {\r\n                    const val = this.src.slice(valStart, this.pos);\r\n                    this.pos++; // closing quote\r\n                    return val;\r\n                }\r\n                if (ch === '\\n' || ch === '\\r') {\r\n                    // Unterminated quoted attribute \u2014 stop here\r\n                    const val = this.src.slice(valStart, this.pos);\r\n                    this.diagnostics.push(makeError(\r\n                        'HXML002',\r\n                        `Unterminated attribute value (missing closing ${q})`,\r\n                        this.tracker.range(quoteStart, this.pos),\r\n                        'Add a closing quote to the attribute value',\r\n                    ));\r\n                    return val;\r\n                }\r\n                this.pos++;\r\n            }\r\n            // EOF without closing quote\r\n            const val = this.src.slice(valStart, this.pos);\r\n            this.diagnostics.push(makeError(\r\n                'HXML002',\r\n                `Unterminated attribute value (missing closing ${q})`,\r\n                this.tracker.range(quoteStart, this.pos),\r\n                'Add a closing quote to the attribute value',\r\n            ));\r\n            return val;\r\n        }\r\n        // Unquoted attribute value\r\n        return this.readWhile(ch => /[^\\s>\\/]/.test(ch));\r\n    }\r\n\r\n    private readAttrs(): TokenAttribute[] {\r\n        const attrs: TokenAttribute[] = [];\r\n        while (!this.eof()) {\r\n            this.skipWS();\r\n            if (this.peek() === '>' || this.match('/>')) break;\r\n\r\n            const attrStart = this.pos;\r\n            const name = this.readWhile(ch => /[^\\s=>\\/\"']/.test(ch));\r\n            if (!name) break;\r\n\r\n            let value: string | null = null;\r\n            this.skipWS();\r\n            if (this.peek() === '=') {\r\n                this.consume(); // =\r\n                this.skipWS();\r\n                value = this.readAttrValue();\r\n            }\r\n            const attrEnd = this.pos;\r\n\r\n            attrs.push({\r\n                name,\r\n                value,\r\n                loc: this.tracker.range(attrStart, attrEnd),\r\n            });\r\n        }\r\n        return attrs;\r\n    }\r\n\r\n    // \u2500\u2500 Raw text mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    /**\r\n     * After an open tag for a raw text element (script, style, textarea, title),\r\n     * consume everything as a single TEXT token until the matching close tag.\r\n     */\r\n    private readRawText(tagName: string): Token | null {\r\n        const start = this.pos;\r\n        const closeTag = `</${tagName.toLowerCase()}`;\r\n\r\n        // Scan for the close tag using case-insensitive matching without\r\n        // allocating a full lowercased copy of the source.\r\n        while (this.pos < this.src.length) {\r\n            // Find the next '<' character as a quick scan\r\n            const ltIdx = this.src.indexOf('<', this.pos);\r\n            if (ltIdx < 0) break;\r\n\r\n            // Check if this '<' begins our close tag (case-insensitive)\r\n            this.pos = ltIdx;\r\n            if (this.pos + closeTag.length <= this.src.length && this.matchCI(closeTag)) {\r\n                // Check that what follows the close tag name is whitespace or >\r\n                const afterTag = this.src[this.pos + closeTag.length];\r\n                if (afterTag === '>' || afterTag === ' ' || afterTag === '\\t' ||\r\n                    afterTag === '\\n' || afterTag === '\\r' || afterTag === undefined) {\r\n                    const text = this.src.slice(start, ltIdx);\r\n                    this.pos = ltIdx; // position at the start of the close tag\r\n                    if (text) {\r\n                        return {\r\n                            type: 'TEXT',\r\n                            value: text,\r\n                            loc: this.tracker.range(start, ltIdx),\r\n                        };\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // False positive \u2014 skip past this '<'\r\n            this.pos = ltIdx + 1;\r\n        }\r\n\r\n        // No matching close tag \u2014 consume everything\r\n        this.pos = this.src.length;\r\n        const text = this.src.slice(start);\r\n        if (text) {\r\n            return {\r\n                type: 'TEXT',\r\n                value: text,\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Pending token for raw-text-element content\r\n    private _pending: Token | null = null;\r\n\r\n    // \u2500\u2500 Main tokenization \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    nextToken(): Token | null {\r\n        if (this._pending) {\r\n            const t = this._pending;\r\n            this._pending = null;\r\n            return t;\r\n        }\r\n        if (this.eof()) return null;\r\n\r\n        const start = this.pos;\r\n\r\n        // \u2500\u2500 Comment: <!-- ... -->\r\n        if (this.match('<!--')) {\r\n            this.consume(4);\r\n            const value = this.readUntil('-->');\r\n            return {\r\n                type: 'COMMENT',\r\n                value,\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n        }\r\n\r\n        // \u2500\u2500 CDATA: <![CDATA[ ... ]]>\r\n        if (this.match('<![CDATA[')) {\r\n            this.consume(9);\r\n            const value = this.readUntil(']]>');\r\n            return {\r\n                type: 'CDATA',\r\n                value,\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n        }\r\n\r\n        // \u2500\u2500 DOCTYPE: <!DOCTYPE ...>\r\n        if (this.match('<!') && this.matchCI('<!DOCTYPE')) {\r\n            this.consume(9); // <!DOCTYPE\r\n            this.skipWS();\r\n            const value = this.readUntil('>').trim();\r\n            return {\r\n                type: 'DOCTYPE',\r\n                value,\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n        }\r\n\r\n        // \u2500\u2500 Unknown markup declaration: <!something that isn't DOCTYPE, --, or [CDATA[\r\n        // In HTML5 this is a \"bogus comment\". Consume to '>' and emit a diagnostic.\r\n        if (this.match('<!')) {\r\n            this.consume(2); // <!\r\n            const body = this.readUntil('>');\r\n            this.diagnostics.push(makeError(\r\n                'HXML003',\r\n                `Unrecognised markup declaration: \"<!${body.trimEnd()}\"`,\r\n                this.tracker.range(start, this.pos),\r\n                'Valid markup declarations are <!--comment-->, <![CDATA[...]]>, or <!DOCTYPE ...>',\r\n            ));\r\n            // Return an empty text token \u2014 the bogus content is discarded.\r\n            return {\r\n                type: 'TEXT',\r\n                value: '',\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n        }\r\n\r\n        // \u2500\u2500 Processing Instruction: <? ... ?>\r\n        if (this.match('<?')) {\r\n            this.consume(2);\r\n            const raw = this.readUntil('?>').trim();\r\n            // Split target from data\r\n            const spaceIdx = raw.search(/\\s/);\r\n            const target = spaceIdx < 0 ? raw : raw.slice(0, spaceIdx);\r\n            const data = spaceIdx < 0 ? '' : raw.slice(spaceIdx).trim();\r\n            return {\r\n                type: 'PI',\r\n                target,\r\n                data,\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n        }\r\n\r\n        // \u2500\u2500 Tags\r\n        if (this.peek() === '<') {\r\n            this.consume(); // <\r\n\r\n            // \u2500\u2500 Close tag: </name>\r\n            if (this.peek() === '/') {\r\n                this.consume(); // /\r\n                const name = this.readWhile(ch => /[^\\s>]/.test(ch));\r\n                this.skipWS();\r\n                if (this.peek() === '>') this.consume();\r\n                return {\r\n                    type: 'CLOSE_TAG',\r\n                    name,\r\n                    loc: this.tracker.range(start, this.pos),\r\n                };\r\n            }\r\n\r\n            // \u2500\u2500 Open tag: <name attrs... > or <name attrs... />\r\n            const name = this.readWhile(ch => /[^\\s>\\/<]/.test(ch));\r\n            if (!name) {\r\n                // Bare `<` that's not a tag \u2014 emit as text\r\n                return {\r\n                    type: 'TEXT',\r\n                    value: '<',\r\n                    loc: this.tracker.range(start, this.pos),\r\n                };\r\n            }\r\n\r\n            const attrs = this.readAttrs();\r\n            this.skipWS();\r\n            const selfClosing = this.match('/>');\r\n            if (selfClosing) {\r\n                this.consume(2);\r\n            } else if (this.peek() === '>') {\r\n                this.consume();\r\n            }\r\n\r\n            const token: OpenTagToken = {\r\n                type: 'OPEN_TAG',\r\n                name,\r\n                attrs,\r\n                selfClosing,\r\n                loc: this.tracker.range(start, this.pos),\r\n            };\r\n\r\n            // If this is a raw text element (HTML, no prefix), enter raw text mode\r\n            const lo = name.toLowerCase();\r\n            if (!name.includes(':') && HTML_RAW_TEXT_ELEMENTS.has(lo)) {\r\n                // We return the open tag token now.  The *next* call to nextToken()\r\n                // should return raw text.  We handle this by peeking ahead.\r\n                // Actually, we emit the open tag and queue the raw text.\r\n                // Simpler: stash raw-text token if available.\r\n                const rawToken = this.readRawText(name);\r\n                if (rawToken) {\r\n                    this._pending = rawToken;\r\n                }\r\n            }\r\n\r\n            return token;\r\n        }\r\n\r\n        // \u2500\u2500 Text content\r\n        const text = this.readWhile(ch => ch !== '<');\r\n        return {\r\n            type: 'TEXT',\r\n            value: text,\r\n            loc: this.tracker.range(start, this.pos),\r\n        };\r\n    }\r\n\r\n    /** Tokenize the entire source into an array of tokens. */\r\n    tokenize(): Token[] {\r\n        const tokens: Token[] = [];\r\n        let tok: Token | null;\r\n        while ((tok = this.nextToken()) !== null) {\r\n            tokens.push(tok);\r\n        }\r\n        return tokens;\r\n    }\r\n}\r\n", "/**\r\n * parser.ts \u2014 Token stream \u2192 AST tree builder for HXML.\r\n *\r\n * Consumes tokens from the tokenizer and builds the AST.  Handles:\r\n * - Mode switching (colon in tag name \u2192 XML mode)\r\n * - HTML auto-close rules\r\n * - Hierarchical namespace scope chain\r\n * - Error recovery (always produces a complete AST)\r\n */\r\n\r\nimport type {\r\n    RootNode, ElementNode, HxmlNode, ParsingMode, Attribute,\r\n} from './ast.js';\r\nimport { Tokenizer, type Token } from './tokenizer.js';\r\nimport {\r\n    HTML_VOID_ELEMENTS,\r\n    HTML_AUTO_CLOSE_BEFORE,\r\n    PREDECLARED_NAMESPACES,\r\n} from './constants.js';\r\nimport type { SourceRange } from './utils/source-map.js';\r\nimport { makeError, type Diagnostic } from './utils/errors.js';\r\n\r\n// \u2500\u2500 Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport interface ParseResult {\r\n    ast: RootNode;\r\n    diagnostics: Diagnostic[];\r\n}\r\n\r\nexport interface ParseOptions {\r\n    /** If true, don't discard whitespace-only text nodes in HTML mode. */\r\n    preserveWhitespace?: boolean;\r\n}\r\n\r\n// \u2500\u2500 Stack entry \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\ninterface StackEntry {\r\n    node: ElementNode | RootNode;\r\n    mode: ParsingMode;\r\n    /** Namespace declarations on this element.  prefix \u2192 URI. */\r\n    namespaces: Map<string, string>;\r\n}\r\n\r\n// \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction isXmlName(name: string): boolean {\r\n    return name.includes(':');\r\n}\r\n\r\nfunction splitName(name: string): { prefix: string | null; localName: string } {\r\n    const idx = name.indexOf(':');\r\n    if (idx < 0) return { prefix: null, localName: name };\r\n    return { prefix: name.slice(0, idx), localName: name.slice(idx + 1) };\r\n}\r\n\r\nfunction emptyRange(): SourceRange {\r\n    const pos = { line: 1, col: 0, offset: 0 };\r\n    return { start: pos, end: pos };\r\n}\r\n\r\n// \u2500\u2500 Parser \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport function parse(source: string, options?: ParseOptions): ParseResult {\r\n    const tokenizer = new Tokenizer(source);\r\n    const tokens = tokenizer.tokenize();\r\n    const diagnostics: Diagnostic[] = [...tokenizer.diagnostics];\r\n    const preserveWhitespace = options?.preserveWhitespace ?? false;\r\n\r\n    // Root node\r\n    const root: RootNode = {\r\n        type: 'root',\r\n        children: [],\r\n        mode: 'html',\r\n        loc: emptyRange(),\r\n    };\r\n\r\n    // Element stack \u2014 tracks nesting and namespace scope\r\n    const stack: StackEntry[] = [{\r\n        node: root,\r\n        mode: 'html',\r\n        namespaces: new Map(PREDECLARED_NAMESPACES),\r\n    }];\r\n\r\n    const current = (): StackEntry => stack[stack.length - 1];\r\n\r\n    // \u2500\u2500 Auto-close logic \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    /**\r\n     * Before opening a new HTML element, check if any ancestor HTML elements\r\n     * should be auto-closed.  Walk down from the top of the stack.\r\n     */\r\n    function autoCloseBefore(openName: string): void {\r\n        const lo = openName.toLowerCase();\r\n\r\n        // Loop because closing one element may expose another that also\r\n        // needs to auto-close. E.g. opening <optgroup> first auto-closes\r\n        // the <option> child, then auto-closes the previous <optgroup>.\r\n        let didClose = true;\r\n        while (didClose) {\r\n            didClose = false;\r\n            for (let i = stack.length - 1; i > 0; i--) {\r\n                const entry = stack[i];\r\n                if (entry.node.type !== 'element') continue;\r\n\r\n                // Don't auto-close across XML boundaries\r\n                if (entry.mode === 'xml') break;\r\n\r\n                const stackName = entry.node.name.toLowerCase();\r\n                const closeSet = HTML_AUTO_CLOSE_BEFORE[stackName];\r\n\r\n                if (closeSet && closeSet.has(lo)) {\r\n                    // Pop everything from position i upward\r\n                    stack.splice(i);\r\n                    didClose = true;\r\n                    break; // restart the scan from the new top\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u2500\u2500 Process tokens \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    for (const token of tokens) {\r\n        switch (token.type) {\r\n            case 'TEXT': {\r\n                const parentMode = current().mode;\r\n                // In HTML mode, skip whitespace-only text nodes (unless preserved)\r\n                if (!preserveWhitespace && parentMode === 'html' && !token.value.trim()) {\r\n                    continue;\r\n                }\r\n                const textNode: HxmlNode = {\r\n                    type: 'text',\r\n                    value: token.value,\r\n                    mode: parentMode,\r\n                    loc: token.loc,\r\n                };\r\n                (current().node.children as HxmlNode[]).push(textNode);\r\n                break;\r\n            }\r\n\r\n            case 'COMMENT': {\r\n                const commentNode: HxmlNode = {\r\n                    type: 'comment',\r\n                    value: token.value,\r\n                    mode: current().mode,\r\n                    loc: token.loc,\r\n                };\r\n                (current().node.children as HxmlNode[]).push(commentNode);\r\n                break;\r\n            }\r\n\r\n            case 'CDATA': {\r\n                const cdataNode: HxmlNode = {\r\n                    type: 'cdata',\r\n                    value: token.value,\r\n                    mode: current().mode,\r\n                    loc: token.loc,\r\n                };\r\n                (current().node.children as HxmlNode[]).push(cdataNode);\r\n                break;\r\n            }\r\n\r\n            case 'PI': {\r\n                const piNode: HxmlNode = {\r\n                    type: 'processingInstruction',\r\n                    target: token.target,\r\n                    data: token.data,\r\n                    mode: current().mode,\r\n                    loc: token.loc,\r\n                };\r\n                (current().node.children as HxmlNode[]).push(piNode);\r\n                break;\r\n            }\r\n\r\n            case 'DOCTYPE': {\r\n                const doctypeNode: HxmlNode = {\r\n                    type: 'doctype',\r\n                    value: token.value,\r\n                    mode: 'html',\r\n                    loc: token.loc,\r\n                };\r\n                // DOCTYPE always goes on root\r\n                root.children.push(doctypeNode);\r\n                break;\r\n            }\r\n\r\n            case 'OPEN_TAG': {\r\n                const xmlMode = isXmlName(token.name);\r\n                const mode: ParsingMode = xmlMode ? 'xml' : 'html';\r\n                const { prefix, localName } = splitName(token.name);\r\n\r\n                // Multiple colons in a tag name (e.g. <a:b:c>) are not valid in\r\n                // either XML or HTML.  Emit a diagnostic but continue parsing\r\n                // using the first colon as the prefix boundary.\r\n                if (xmlMode && localName.includes(':')) {\r\n                    diagnostics.push(makeError(\r\n                        'HXML104',\r\n                        `Tag name \"${token.name}\" contains more than one colon`,\r\n                        token.loc,\r\n                        'XML tag names may have at most one colon separating prefix and local name',\r\n                    ));\r\n                }\r\n\r\n                // Collect namespace declarations from attributes\r\n                const nsDecls = new Map<string, string>();\r\n                for (const attr of token.attrs) {\r\n                    if (attr.name.startsWith('xmlns:')) {\r\n                        const nsPrefix = attr.name.slice(6);\r\n                        nsDecls.set(nsPrefix, attr.value ?? '');\r\n                    } else if (attr.name === 'xmlns') {\r\n                        nsDecls.set('#default', attr.value ?? '');\r\n                    }\r\n                }\r\n\r\n                // HTML auto-close rules \u2014 only for HTML-mode elements\r\n                if (!xmlMode) {\r\n                    autoCloseBefore(token.name);\r\n                }\r\n\r\n                // Convert token attributes to AST attributes\r\n                const attrs: Attribute[] = token.attrs.map(a => ({\r\n                    name: a.name,\r\n                    value: a.value,\r\n                    loc: a.loc,\r\n                }));\r\n\r\n                const lo = token.name.toLowerCase();\r\n                const isVoid = (!xmlMode && HTML_VOID_ELEMENTS.has(lo)) || token.selfClosing;\r\n\r\n                // Build the element node\r\n                const element: ElementNode = {\r\n                    type: 'element',\r\n                    name: token.name,\r\n                    prefix,\r\n                    localName,\r\n                    attrs,\r\n                    namespaces: nsDecls,\r\n                    selfClosing: token.selfClosing,\r\n                    isVoid,\r\n                    children: [],\r\n                    mode,\r\n                    loc: token.loc,\r\n                };\r\n\r\n                // Append to current parent\r\n                (current().node.children as HxmlNode[]).push(element);\r\n\r\n                // Push onto stack if not void/self-closing\r\n                if (!isVoid) {\r\n                    stack.push({\r\n                        node: element,\r\n                        mode,\r\n                        namespaces: nsDecls,\r\n                    });\r\n                }\r\n                break;\r\n            }\r\n\r\n            case 'CLOSE_TAG': {\r\n                const xmlExpected = isXmlName(token.name);\r\n\r\n                // Find matching open element on the stack\r\n                let found = -1;\r\n                for (let i = stack.length - 1; i > 0; i--) {\r\n                    const entry = stack[i];\r\n                    if (entry.node.type !== 'element') continue;\r\n                    const stackName = entry.node.name;\r\n\r\n                    // XML: exact match.  HTML: case-insensitive match.\r\n                    if (xmlExpected) {\r\n                        if (stackName === token.name) { found = i; break; }\r\n                    } else {\r\n                        if (stackName.toLowerCase() === token.name.toLowerCase()) { found = i; break; }\r\n                    }\r\n                }\r\n\r\n                if (found < 0) {\r\n                    diagnostics.push(makeError(\r\n                        'HXML101',\r\n                        `Unmatched closing tag </${token.name}>`,\r\n                        token.loc,\r\n                    ));\r\n                    continue;\r\n                }\r\n\r\n                // If there are unclosed elements between the match and stack top,\r\n                // that's an error for XML-mode elements but normal for HTML.\r\n                if (found < stack.length - 1) {\r\n                    const unclosed = stack.slice(found + 1);\r\n                    for (const entry of unclosed) {\r\n                        if (entry.mode === 'xml' && entry.node.type === 'element') {\r\n                            diagnostics.push(makeError(\r\n                                'HXML102',\r\n                                `Unclosed XML element <${entry.node.name}> inside <${token.name}>`,\r\n                                entry.node.loc,\r\n                                `Add </${entry.node.name}> before </${token.name}>`,\r\n                            ));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Pop the stack down to and including the found element\r\n                stack.splice(found);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u2500\u2500 Check for unclosed elements at end of input \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n    for (let i = 1; i < stack.length; i++) {\r\n        const entry = stack[i];\r\n        if (entry.mode === 'xml' && entry.node.type === 'element') {\r\n            diagnostics.push(makeError(\r\n                'HXML103',\r\n                `XML element <${entry.node.name}> was never closed`,\r\n                entry.node.loc,\r\n                `Add </${entry.node.name}>`,\r\n            ));\r\n        }\r\n    }\r\n\r\n    // Update root loc\r\n    if (tokens.length > 0) {\r\n        root.loc = {\r\n            start: tokens[0].loc.start,\r\n            end: tokens[tokens.length - 1].loc.end,\r\n        };\r\n    }\r\n\r\n    return { ast: root, diagnostics };\r\n}\r\n", "/**\r\n * vlq.ts \u2014 Base64 VLQ encoding for V3 source maps.\r\n *\r\n * A V3 source map `mappings` field encodes groups of signed integers\r\n * as Base64 VLQ.  Each integer is split into 5-bit groups; the low bit\r\n * of the last group is the sign and each non-final group has a\r\n * continuation bit set (bit 5).\r\n *\r\n * Reference: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k\r\n */\r\n\r\nconst BASE64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n/** Encode a single signed integer as Base64 VLQ. */\r\nexport function encodeVlqInt(value: number): string {\r\n    // Convert to unsigned: the sign bit is the LSB.\r\n    let vlq = value < 0 ? ((-value) << 1) | 1 : value << 1;\r\n    let result = '';\r\n    do {\r\n        let digit = vlq & 0x1F; // take 5 bits\r\n        vlq >>>= 5;\r\n        if (vlq > 0) digit |= 0x20; // set continuation bit\r\n        result += BASE64[digit];\r\n    } while (vlq > 0);\r\n    return result;\r\n}\r\n\r\n/** Encode an array of signed integers as a single Base64 VLQ segment. */\r\nexport function encodeVlqSegment(values: number[]): string {\r\n    return values.map(encodeVlqInt).join('');\r\n}\r\n", "/**\r\n * escape.ts \u2014 HTML escaping and sanitization helpers for HXML output.\r\n */\r\n\r\n/** Escape text content for safe inclusion in HTML. */\r\nexport function escapeHtml(s: string): string {\r\n    return s\r\n        .replace(/&/g, '&amp;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;');\r\n}\r\n\r\n/** Escape a string for safe inclusion in an HTML attribute value. */\r\nexport function escapeAttr(s: string): string {\r\n    return s\r\n        .replace(/&/g, '&amp;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;');\r\n}\r\n\r\n/**\r\n * Sanitize comment text so it cannot break out of an HTML comment.\r\n * HTML comments must not contain `--`, so we insert a space: `--` \u2192 `- -`.\r\n */\r\nexport function sanitizeComment(s: string): string {\r\n    return s.replace(/--/g, '- -');\r\n}\r\n\r\n/**\r\n * Sanitize processing instruction data so it cannot break out of a PI.\r\n * PIs are terminated by `?>`, so we insert a space: `?>` \u2192 `? >`.\r\n */\r\nexport function sanitizePI(s: string): string {\r\n    return s.replace(/\\?>/g, '? >');\r\n}\r\n", "/**\r\n * emitter.ts \u2014 AST \u2192 HTML5 output for HXML.\r\n *\r\n * Serializes an HXML AST back to valid HTML5.  The default emit mode\r\n * (\"custom-elements\") transforms XML-mode elements into Custom Elements\r\n * with hyphenated tag names.\r\n */\r\n\r\nimport type {\r\n    RootNode, HxmlNode, ElementNode, Attribute,\r\n} from './ast.js';\r\nimport { HTML_RAW_TEXT_ELEMENTS, HTML_INLINE_ELEMENTS, FOREIGN_CONTENT_NAMESPACES, PREDECLARED_NAMESPACES } from './constants.js';\r\nimport type { SourceRange } from './utils/source-map.js';\r\nimport { encodeVlqSegment } from './utils/vlq.js';\r\nimport { escapeHtml, escapeAttr, sanitizeComment, sanitizePI } from './utils/escape.js';\r\n\r\n// \u2500\u2500 Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport type EmitMode =\r\n    | 'custom-elements'   // prefix:local \u2192 prefix-local (Custom Elements)\r\n    | 'data-attributes'   // XML elements \u2192 <div data-hxml-tag=\"...\">\r\n    | 'passthrough'       // XML elements emitted as-is\r\n    | 'strip';            // XML elements removed, only text content kept\r\n\r\nexport interface EmitOptions {\r\n    mode?: EmitMode;\r\n    /** Indent string, default ''. Pass '  ' (2 spaces) for formatted output. */\r\n    indent?: string;\r\n    /** Whether to include the DOCTYPE.  Default true. */\r\n    doctype?: boolean;\r\n    /**\r\n     * When true, generate a V3 source map alongside the HTML output.\r\n     * The source path used in the map can be set via `sourceFile`.\r\n     */\r\n    sourceMap?: boolean;\r\n    /** Source file path embedded in the source map.  Default: \"input.hxml\". */\r\n    sourceFile?: string;\r\n}\r\n\r\nexport interface EmitResult {\r\n    html: string;\r\n    /** V3 source map JSON string.  Only present when `options.sourceMap` is true. */\r\n    sourceMap?: string;\r\n}\r\n\r\n// \u2500\u2500 Source map builder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n/**\r\n * Collects {text, sourceLoc?} segments as the emitter runs, then assembles\r\n * both the final HTML string and a V3 source map.\r\n *\r\n * Every call to write() with a non-null `loc` generates a source map segment\r\n * mapping that output position back to the HXML source position.\r\n */\r\nclass SourceMapBuilder {\r\n    private readonly segments: Array<{ text: string; loc?: SourceRange }> = [];\r\n\r\n    write(text: string, loc?: SourceRange): void {\r\n        if (text) this.segments.push({ text, loc });\r\n    }\r\n\r\n    buildHtml(): string {\r\n        return this.segments.map(s => s.text).join('');\r\n    }\r\n\r\n    buildSourceMap(sourceFile: string, sourceContent?: string): string {\r\n        // Walk segments tracking (genLine, genCol) and last source position.\r\n        let genLine = 0;\r\n        let genCol = 0;\r\n        let prevGenCol = 0;\r\n        let prevSrcLine = 0;\r\n        let prevSrcCol = 0;\r\n\r\n        // lineGroups[i] = array of encoded segment strings for output line i.\r\n        const lineGroups: string[][] = [[]];\r\n\r\n        for (const seg of this.segments) {\r\n            if (seg.loc) {\r\n                // Source positions are 1-based line, 0-based col.\r\n                const srcLine = seg.loc.start.line - 1;\r\n                const srcCol = seg.loc.start.col;\r\n\r\n                const encoded = encodeVlqSegment([\r\n                    genCol - prevGenCol,\r\n                    0,                       // source index (always 0 \u2014 one source file)\r\n                    srcLine - prevSrcLine,\r\n                    srcCol - prevSrcCol,\r\n                ]);\r\n                lineGroups[genLine].push(encoded);\r\n\r\n                prevGenCol = genCol;\r\n                prevSrcLine = srcLine;\r\n                prevSrcCol = srcCol;\r\n            }\r\n\r\n            // Advance generated position through the emitted text.\r\n            for (let i = 0; i < seg.text.length; i++) {\r\n                if (seg.text[i] === '\\n') {\r\n                    genLine++;\r\n                    genCol = 0;\r\n                    prevGenCol = 0; // reset per-line delta\r\n                    if (genLine >= lineGroups.length) lineGroups.push([]);\r\n                } else {\r\n                    genCol++;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mappings = lineGroups.map(g => g.join(',')).join(';');\r\n        const map: Record<string, unknown> = {\r\n            version: 3,\r\n            sources: [sourceFile],\r\n            names: [],\r\n            mappings,\r\n        };\r\n        if (sourceContent !== undefined) {\r\n            map['sourcesContent'] = [sourceContent];\r\n        }\r\n        return JSON.stringify(map);\r\n    }\r\n}\r\n\r\n// \u2500\u2500 Namespace context for resolution during emit \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\ntype NsContext = Map<string, string>;\r\n\r\nfunction mergeNs(parent: NsContext, element: ElementNode): NsContext {\r\n    if (element.namespaces.size === 0) return parent;\r\n    const merged = new Map(parent);\r\n    for (const [k, v] of element.namespaces) merged.set(k, v);\r\n    return merged;\r\n}\r\n\r\n// \u2500\u2500 Emitter \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport function emit(ast: RootNode, options?: EmitOptions): EmitResult {\r\n    const mode = options?.mode ?? 'custom-elements';\r\n    const indent = options?.indent ?? '';\r\n    const includeDoctype = options?.doctype ?? true;\r\n    const wantSourceMap = options?.sourceMap ?? false;\r\n    const rootNs: NsContext = new Map(PREDECLARED_NAMESPACES);\r\n\r\n    // Always use SourceMapBuilder as the output channel so every node gets\r\n    // a source location segment when source maps are enabled.\r\n    const smb = new SourceMapBuilder();\r\n\r\n    for (const node of ast.children) {\r\n        emitNode(node, mode, indent, 0, includeDoctype, false, rootNs, smb);\r\n    }\r\n\r\n    const html = smb.buildHtml();\r\n\r\n    if (wantSourceMap) {\r\n        const sourceFile = options?.sourceFile ?? 'input.hxml';\r\n        return { html, sourceMap: smb.buildSourceMap(sourceFile) };\r\n    }\r\n\r\n    return { html };\r\n}\r\n\r\n// \u2500\u2500 Node emission \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction emitNode(\r\n    node: HxmlNode,\r\n    mode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    includeDoctype: boolean,\r\n    rawTextParent: boolean,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    switch (node.type) {\r\n        case 'text':\r\n            smb.write(rawTextParent ? node.value : escapeHtml(node.value), node.loc);\r\n            return;\r\n\r\n        case 'comment':\r\n            smb.write(`<!--${sanitizeComment(node.value)}-->`, node.loc);\r\n            return;\r\n\r\n        case 'cdata':\r\n            // HTML5 has no CDATA \u2014 entity-escape the content\r\n            smb.write(escapeHtml(node.value), node.loc);\r\n            return;\r\n\r\n        case 'processingInstruction':\r\n            // XML declarations (<?xml ...?>) carry no meaning in HTML5 output.\r\n            if (node.target === 'xml') return;\r\n            // All other PIs serialise as HTML bogus comments per the HTML5 spec.\r\n            smb.write(`<!--?${node.target}${node.data ? ' ' + sanitizePI(node.data) : ''}?-->`, node.loc);\r\n            return;\r\n\r\n        case 'doctype':\r\n            smb.write(includeDoctype ? '<!DOCTYPE html>\\n' : '', node.loc);\r\n            return;\r\n\r\n        case 'element':\r\n            emitElement(node, mode, indent, depth, nsCtx, smb);\r\n            return;\r\n    }\r\n}\r\n\r\nfunction emitElement(\r\n    element: ElementNode,\r\n    mode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    const childNs = mergeNs(nsCtx, element);\r\n\r\n    // XML-mode elements get transformed based on the emit mode\r\n    if (element.mode === 'xml') {\r\n        emitXmlElement(element, mode, indent, depth, childNs, smb);\r\n        return;\r\n    }\r\n\r\n    // HTML-mode elements pass through as-is\r\n    emitHtmlElement(element, mode, indent, depth, childNs, smb);\r\n}\r\n\r\n// \u2500\u2500 HTML element emission \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction emitHtmlElement(\r\n    element: ElementNode,\r\n    mode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    const tagName = element.name.toLowerCase();\r\n    const isRawText = HTML_RAW_TEXT_ELEMENTS.has(tagName);\r\n    let openTag = `<${tagName}`;\r\n\r\n    // Emit attributes (skip xmlns:*)\r\n    for (const attr of element.attrs) {\r\n        if (attr.name.startsWith('xmlns:') || attr.name === 'xmlns') continue;\r\n        openTag += emitAttr(attr);\r\n    }\r\n\r\n    if (element.isVoid) {\r\n        openTag += '>';\r\n        smb.write(openTag, element.loc);\r\n        return;\r\n    }\r\n\r\n    openTag += '>';\r\n    smb.write(openTag, element.loc);\r\n    emitChildren(element.children, mode, indent, depth, nsCtx, isRawText, smb);\r\n    smb.write(`</${tagName}>`);\r\n}\r\n\r\n// \u2500\u2500 XML element emission \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction emitXmlElement(\r\n    element: ElementNode,\r\n    emitMode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    switch (emitMode) {\r\n        case 'custom-elements':\r\n            emitAsCustomElement(element, emitMode, indent, depth, nsCtx, smb);\r\n            return;\r\n        case 'data-attributes':\r\n            emitAsDataAttributes(element, emitMode, indent, depth, nsCtx, smb);\r\n            return;\r\n        case 'passthrough':\r\n            emitAsPassthrough(element, emitMode, indent, depth, nsCtx, smb);\r\n            return;\r\n        case 'strip':\r\n            emitAsStripped(element, emitMode, indent, depth, nsCtx, smb);\r\n            return;\r\n    }\r\n}\r\n\r\n/**\r\n * Custom Elements mode: `prefix:local` \u2192 `prefix-local`\r\n * Namespace attrs \u2192 `data-xmlns-*`\r\n */\r\nfunction emitAsCustomElement(\r\n    element: ElementNode,\r\n    emitMode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    // Check if this element's namespace is a known foreign content namespace\r\n    // (SVG or MathML). If so, emit using native HTML5 foreign content syntax.\r\n    if (element.prefix) {\r\n        const nsUri = nsCtx.get(element.prefix);\r\n        if (nsUri && nsUri in FOREIGN_CONTENT_NAMESPACES) {\r\n            emitAsForeignContent(element, emitMode, indent, depth, nsCtx, nsUri, smb);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Transform tag name: data:record \u2192 data-record\r\n    const customTag = element.prefix\r\n        ? `${element.prefix}-${element.localName}`\r\n        : element.localName;\r\n\r\n    let openTag = `<${customTag}`;\r\n\r\n    // Transform attributes\r\n    for (const attr of element.attrs) {\r\n        if (attr.name.startsWith('xmlns:')) {\r\n            // xmlns:data=\"urn:app\" \u2192 data-xmlns-data=\"urn:app\"\r\n            const prefix = attr.name.slice(6);\r\n            openTag += ` data-xmlns-${prefix}=\"${escapeAttr(attr.value ?? '')}\"`;\r\n        } else if (attr.name === 'xmlns') {\r\n            openTag += ` data-xmlns=\"${escapeAttr(attr.value ?? '')}\"`;\r\n        } else {\r\n            openTag += emitAttr(attr);\r\n        }\r\n    }\r\n\r\n    if (element.isVoid && element.children.length === 0) {\r\n        openTag += `></${customTag}>`;\r\n        smb.write(openTag, element.loc);\r\n        return;\r\n    }\r\n\r\n    openTag += '>';\r\n    smb.write(openTag, element.loc);\r\n    emitChildren(element.children, emitMode, indent, depth, nsCtx, false, smb);\r\n    smb.write(`</${customTag}>`);\r\n}\r\n\r\n/**\r\n * Foreign content mode: SVG/MathML elements are emitted using native\r\n * HTML5 foreign content syntax. The outermost element in the namespace\r\n * group becomes the foreign content root (e.g. <svg>, <math>).\r\n */\r\nfunction emitAsForeignContent(\r\n    element: ElementNode,\r\n    emitMode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    nsUri: string,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    // Use localName only \u2014 strip the namespace prefix\r\n    const tagName = element.localName;\r\n    let openTag = `<${tagName}`;\r\n\r\n    // Emit non-namespace attributes\r\n    for (const attr of element.attrs) {\r\n        if (attr.name.startsWith('xmlns:') || attr.name === 'xmlns') continue;\r\n        openTag += emitAttr(attr);\r\n    }\r\n\r\n    if (element.isVoid && element.children.length === 0) {\r\n        openTag += '/>';\r\n        smb.write(openTag, element.loc);\r\n        return;\r\n    }\r\n\r\n    openTag += '>';\r\n    smb.write(openTag, element.loc);\r\n    emitChildren(element.children, emitMode, indent, depth, nsCtx, false, smb);\r\n    smb.write(`</${tagName}>`);\r\n}\r\n\r\n/**\r\n * Data-attributes mode: XML elements \u2192 <div data-hxml-tag=\"prefix:local\">\r\n */\r\nfunction emitAsDataAttributes(\r\n    element: ElementNode,\r\n    emitMode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    const wrapper = 'div';\r\n    let openTag = `<${wrapper} data-hxml-tag=\"${escapeAttr(element.name)}\"`;\r\n\r\n    for (const attr of element.attrs) {\r\n        if (attr.name.startsWith('xmlns:') || attr.name === 'xmlns') {\r\n            const dataName = attr.name === 'xmlns'\r\n                ? 'data-xmlns'\r\n                : `data-xmlns-${attr.name.slice(6)}`;\r\n            openTag += ` ${dataName}=\"${escapeAttr(attr.value ?? '')}\"`;\r\n        } else if (attr.value === null) {\r\n            openTag += ` data-${attr.name}`;\r\n        } else {\r\n            openTag += ` data-${attr.name}=\"${escapeAttr(attr.value)}\"`;\r\n        }\r\n    }\r\n\r\n    openTag += '>';\r\n    smb.write(openTag, element.loc);\r\n    emitChildren(element.children, emitMode, indent, depth, nsCtx, false, smb);\r\n    smb.write(`</${wrapper}>`);\r\n}\r\n\r\n/**\r\n * Passthrough mode: emit XML elements as-is.\r\n */\r\nfunction emitAsPassthrough(\r\n    element: ElementNode,\r\n    emitMode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    let openTag = `<${element.name}`;\r\n\r\n    for (const attr of element.attrs) {\r\n        openTag += emitAttr(attr);\r\n    }\r\n\r\n    if (element.isVoid && element.children.length === 0) {\r\n        openTag += '/>';\r\n        smb.write(openTag, element.loc);\r\n        return;\r\n    }\r\n\r\n    openTag += '>';\r\n    smb.write(openTag, element.loc);\r\n    emitChildren(element.children, emitMode, indent, depth, nsCtx, false, smb);\r\n    smb.write(`</${element.name}>`);\r\n}\r\n\r\n/**\r\n * Strip mode: remove XML element tags, keep text content only.\r\n */\r\nfunction emitAsStripped(\r\n    element: ElementNode,\r\n    emitMode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    emitChildren(element.children, emitMode, indent, depth, nsCtx, false, smb);\r\n}\r\n\r\n// \u2500\u2500 Shared helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction emitChildren(\r\n    children: HxmlNode[],\r\n    mode: EmitMode,\r\n    indent: string,\r\n    depth: number,\r\n    nsCtx: NsContext,\r\n    rawTextParent: boolean,\r\n    smb: SourceMapBuilder,\r\n): void {\r\n    // Raw text content is always emitted inline with no formatting\r\n    if (rawTextParent || !indent) {\r\n        for (const child of children) {\r\n            emitNode(child, mode, indent, depth + 1, false, rawTextParent, nsCtx, smb);\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Check if children are all inline (text/inline-elements only)\r\n    const hasBlockChild = children.some(c =>\r\n        c.type === 'element' && !HTML_INLINE_ELEMENTS.has(c.name.toLowerCase()),\r\n    );\r\n\r\n    if (!hasBlockChild) {\r\n        // Inline-only children: emit without extra formatting\r\n        for (const child of children) {\r\n            emitNode(child, mode, indent, depth + 1, false, false, nsCtx, smb);\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Block children: indent each child on its own line\r\n    const pad = indent.repeat(depth + 1);\r\n    const closePad = indent.repeat(depth);\r\n\r\n    for (const child of children) {\r\n        // XML declarations produce no output \u2014 skip their indentation too\r\n        if (child.type === 'processingInstruction' && child.target === 'xml') continue;\r\n\r\n        if (child.type === 'text') {\r\n            // Only emit non-empty text content\r\n            const trimmed = child.value.trim();\r\n            if (trimmed) {\r\n                smb.write(`\\n${pad}`);\r\n                smb.write(escapeHtml(trimmed), child.loc);\r\n            }\r\n        } else {\r\n            smb.write(`\\n${pad}`);\r\n            emitNode(child, mode, indent, depth + 1, false, false, nsCtx, smb);\r\n        }\r\n    }\r\n    smb.write(`\\n${closePad}`);\r\n}\r\n\r\nfunction emitAttr(attr: Attribute): string {\r\n    if (attr.value === null) {\r\n        return ` ${attr.name}`;\r\n    }\r\n    return ` ${attr.name}=\"${escapeAttr(attr.value)}\"`;\r\n}\r\n\r\n", "/**\r\n * validator.ts \u2014 Post-parse AST validation for HXML.\r\n *\r\n * Walks the completed AST and performs checks that require whole-tree context:\r\n * - Namespace coherence (every prefix is declared in scope)\r\n * - Attribute uniqueness in XML mode\r\n * - CDATA placement (only inside XML-mode elements)\r\n * - Deprecated patterns\r\n */\r\n\r\nimport type { RootNode, HxmlNode, ElementNode } from './ast.js';\r\nimport { PREDECLARED_NAMESPACES } from './constants.js';\r\nimport type { Diagnostic } from './utils/errors.js';\r\nimport { makeError, makeWarning } from './utils/errors.js';\r\n\r\n// \u2500\u2500 Public API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport function validate(ast: RootNode): Diagnostic[] {\r\n    const diagnostics: Diagnostic[] = [];\r\n    const scopeStack: Map<string, string>[] = [new Map(PREDECLARED_NAMESPACES)];\r\n\r\n    walkChildren(ast.children, diagnostics, scopeStack, 'html');\r\n\r\n    return diagnostics;\r\n}\r\n\r\n// \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction currentScope(\r\n    stack: Map<string, string>[],\r\n): (prefix: string) => string | null {\r\n    return (prefix: string) => {\r\n        for (let i = stack.length - 1; i >= 0; i--) {\r\n            const uri = stack[i].get(prefix);\r\n            if (uri !== undefined) return uri;\r\n        }\r\n        return null;\r\n    };\r\n}\r\n\r\nfunction walkChildren(\r\n    children: HxmlNode[],\r\n    diagnostics: Diagnostic[],\r\n    scopeStack: Map<string, string>[],\r\n    parentMode: 'html' | 'xml',\r\n): void {\r\n    for (const node of children) {\r\n        switch (node.type) {\r\n            case 'element':\r\n                validateElement(node, diagnostics, scopeStack);\r\n                break;\r\n\r\n            case 'cdata':\r\n                // CDATA is only valid inside XML-mode elements\r\n                if (parentMode === 'html') {\r\n                    diagnostics.push(makeWarning(\r\n                        'HXML301',\r\n                        'CDATA section inside HTML-mode element',\r\n                        node.loc,\r\n                        'CDATA is only meaningful inside XML-mode elements',\r\n                    ));\r\n                }\r\n                break;\r\n\r\n            case 'doctype':\r\n                // Check for legacy DOCTYPE\r\n                if (node.value.toLowerCase() !== 'html') {\r\n                    diagnostics.push(makeWarning(\r\n                        'HXML302',\r\n                        `Legacy DOCTYPE: \"${node.value}\"`,\r\n                        node.loc,\r\n                        'Use <!DOCTYPE html> for HXML documents',\r\n                    ));\r\n                }\r\n                break;\r\n\r\n            // text, comment, pi \u2014 no validation needed\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nfunction validateElement(\r\n    element: ElementNode,\r\n    diagnostics: Diagnostic[],\r\n    scopeStack: Map<string, string>[],\r\n): void {\r\n    // Push this element's namespace declarations onto the scope stack\r\n    scopeStack.push(element.namespaces);\r\n\r\n    const resolve = currentScope(scopeStack);\r\n\r\n    // \u2500\u2500 Namespace prefix validation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    if (element.prefix) {\r\n        const uri = resolve(element.prefix);\r\n        if (!uri) {\r\n            diagnostics.push(makeError(\r\n                'HXML201',\r\n                `Namespace prefix \"${element.prefix}\" is not declared on <${element.name}>`,\r\n                element.loc,\r\n                `Add xmlns:${element.prefix}=\"...\" to this element or an ancestor`,\r\n            ));\r\n        }\r\n    }\r\n\r\n    // \u2500\u2500 Namespace declaration uniqueness \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    const seenNsDecls = new Set<string>();\r\n    for (const attr of element.attrs) {\r\n        let key: string | null = null;\r\n\r\n        if (attr.name === 'xmlns') {\r\n            key = '#default';\r\n        } else if (attr.name.startsWith('xmlns:')) {\r\n            key = attr.name.slice(6);\r\n        }\r\n\r\n        if (!key) continue;\r\n\r\n        if (seenNsDecls.has(key)) {\r\n            diagnostics.push(makeError(\r\n                'HXML205',\r\n                `Duplicate namespace declaration for prefix \"${key === '#default' ? '(default)' : key}\" on <${element.name}>`,\r\n                attr.loc,\r\n                'Remove the duplicate xmlns declaration or keep only one value',\r\n            ));\r\n            continue;\r\n        }\r\n\r\n        seenNsDecls.add(key);\r\n    }\r\n\r\n    // \u2500\u2500 Attribute uniqueness in XML mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    if (element.mode === 'xml') {\r\n        const seen = new Set<string>();\r\n        for (const attr of element.attrs) {\r\n            if (seen.has(attr.name)) {\r\n                diagnostics.push(makeError(\r\n                    'HXML202',\r\n                    `Duplicate attribute \"${attr.name}\" on XML element <${element.name}>`,\r\n                    attr.loc,\r\n                    'Remove the duplicate attribute',\r\n                ));\r\n            }\r\n            seen.add(attr.name);\r\n        }\r\n\r\n        // XML attributes must have values (no boolean attributes)\r\n        for (const attr of element.attrs) {\r\n            if (attr.value === null && !attr.name.startsWith('xmlns')) {\r\n                diagnostics.push(makeError(\r\n                    'HXML203',\r\n                    `Attribute \"${attr.name}\" on XML element <${element.name}> must have a value`,\r\n                    attr.loc,\r\n                    `Use ${attr.name}=\"${attr.name}\" for boolean attributes in XML mode`,\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u2500\u2500 Validate prefixed attributes \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    for (const attr of element.attrs) {\r\n        if (attr.name.includes(':') && !attr.name.startsWith('xmlns:') && !attr.name.startsWith('xml:')) {\r\n            const attrPrefix = attr.name.split(':')[0];\r\n            const uri = resolve(attrPrefix);\r\n            if (!uri) {\r\n                diagnostics.push(makeError(\r\n                    'HXML204',\r\n                    `Namespace prefix \"${attrPrefix}\" used in attribute \"${attr.name}\" is not declared`,\r\n                    attr.loc,\r\n                    `Add xmlns:${attrPrefix}=\"...\" to this element or an ancestor`,\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u2500\u2500 Recurse into children \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n    walkChildren(element.children, diagnostics, scopeStack, element.mode);\r\n\r\n    // Pop this element's namespace scope\r\n    scopeStack.pop();\r\n}\r\n", "/**\r\n * converter.ts \u2014 HTML5 \u2192 HXML source conversion.\r\n *\r\n * Since HXML is a superset of HTML5, every HTML document is valid HXML.\r\n * This converter takes HTML5 source and produces formatted HXML source\r\n * with explicit closing tags and consistent indentation, ready to be\r\n * annotated with XML namespace content.\r\n *\r\n * Usage:\r\n *   import { htmlToHxml } from 'hxml';\r\n *   const { hxml } = htmlToHxml('<html><body><p>Hello</body></html>');\r\n *   // => properly indented HXML with explicit </p>, </body>, </html>\r\n */\r\n\r\nimport { parse } from './parser.js';\r\nimport type { HxmlNode, ElementNode } from './ast.js';\r\nimport { HTML_RAW_TEXT_ELEMENTS, HTML_VOID_ELEMENTS, HTML_INLINE_ELEMENTS } from './constants.js';\r\nimport { escapeAttr } from './utils/escape.js';\r\n\r\n// \u2500\u2500 Public API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport interface ConvertOptions {\r\n    /** Indentation string.  Default: '  ' (2 spaces). */\r\n    indent?: string;\r\n    /**\r\n     * If true, preserve the source document's whitespace text nodes verbatim.\r\n     * If false (default), reformat whitespace for consistent indentation.\r\n     */\r\n    preserveWhitespace?: boolean;\r\n}\r\n\r\nexport interface ConvertResult {\r\n    hxml: string;\r\n}\r\n\r\n/**\r\n * Convert an HTML5 source string into equivalent HXML source.\r\n *\r\n * The output is a valid HXML document that:\r\n * - Has explicit closing tags for all elements (no optional-close omissions)\r\n * - Is consistently indented\r\n * - Preserves all comments, processing instructions, and CDATA verbatim\r\n * - Can be safely extended with XML namespace content\r\n */\r\nexport function htmlToHxml(source: string, options?: ConvertOptions): ConvertResult {\r\n    const indent = options?.indent ?? '  ';\r\n    const preserveWhitespace = options?.preserveWhitespace ?? false;\r\n\r\n    const { ast } = parse(source, { preserveWhitespace: true });\r\n    const hxml = serializeNodes(ast.children, indent, 0, preserveWhitespace);\r\n\r\n    return { hxml };\r\n}\r\n\r\n// \u2500\u2500 Serialization \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nfunction serializeNodes(\r\n    nodes: HxmlNode[],\r\n    indent: string,\r\n    depth: number,\r\n    preserveWS: boolean,\r\n): string {\r\n    let out = '';\r\n    for (const node of nodes) {\r\n        out += serializeNode(node, indent, depth, preserveWS);\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction serializeNode(\r\n    node: HxmlNode,\r\n    indent: string,\r\n    depth: number,\r\n    preserveWS: boolean,\r\n): string {\r\n    switch (node.type) {\r\n        case 'doctype':\r\n            // Always emit the standard HTML5 DOCTYPE.\r\n            return `<!DOCTYPE html>\\n`;\r\n\r\n        case 'text':\r\n            // When not preserving whitespace, normalize runs of whitespace to a\r\n            // single space so that re-serialized text doesn't carry stray newlines\r\n            // and indentation from the original source.\r\n            if (!preserveWS) {\r\n                return node.value.replace(/\\s+/g, ' ');\r\n            }\r\n            return node.value;\r\n\r\n        case 'comment':\r\n            return `<!--${node.value}-->`;\r\n\r\n        case 'cdata':\r\n            return `<![CDATA[${node.value}]]>`;\r\n\r\n        case 'processingInstruction':\r\n            return `<?${node.target}${node.data ? ' ' + node.data : ''}?>`;\r\n\r\n        case 'element':\r\n            return serializeElement(node, indent, depth, preserveWS);\r\n    }\r\n}\r\n\r\nfunction serializeElement(\r\n    element: ElementNode,\r\n    indent: string,\r\n    depth: number,\r\n    preserveWS: boolean,\r\n): string {\r\n    // HXML preserves HTML element names in their original case (usually lowercase).\r\n    const tagName = element.mode === 'html' ? element.name.toLowerCase() : element.name;\r\n    const pad = indent.repeat(depth);\r\n    const childPad = indent.repeat(depth + 1);\r\n\r\n    // Open tag with attributes\r\n    let openTag = `<${tagName}`;\r\n    for (const attr of element.attrs) {\r\n        openTag += attr.value === null\r\n            ? ` ${attr.name}`\r\n            : ` ${attr.name}=\"${escapeAttr(attr.value)}\"`;\r\n    }\r\n\r\n    // Void elements: no closing tag, no children\r\n    if (HTML_VOID_ELEMENTS.has(tagName) || element.isVoid) {\r\n        return `${pad}${openTag}>`;\r\n    }\r\n\r\n    // Raw text elements (script, style, textarea, title): preserve content verbatim\r\n    if (HTML_RAW_TEXT_ELEMENTS.has(tagName)) {\r\n        const content = element.children\r\n            .map(c => (c.type === 'text' ? c.value : ''))\r\n            .join('');\r\n        return `${pad}${openTag}>${content}</${tagName}>`;\r\n    }\r\n\r\n    // No children: emit as a single line\r\n    if (element.children.length === 0) {\r\n        return `${pad}${openTag}></${tagName}>`;\r\n    }\r\n\r\n    // Check if the element has any block-level children or multi-line structure.\r\n    // Inline-only elements are emitted on one line; block-mixed get indented.\r\n    const shouldIndent = !preserveWS && hasBlockContent(element.children);\r\n\r\n    if (!shouldIndent) {\r\n        // Inline: emit open tag, children, close tag on one line.\r\n        const inner = serializeNodes(element.children, indent, depth + 1, preserveWS);\r\n        return `${pad}${openTag}>${trimInline(inner)}</${tagName}>`;\r\n    }\r\n\r\n    // Block: emit children indented on their own lines.\r\n    let out = `${pad}${openTag}>\\n`;\r\n    for (const child of element.children) {\r\n        if (child.type === 'text') {\r\n            const raw = preserveWS ? child.value : child.value.replace(/\\s+/g, ' ');\r\n            const v = raw.trim();\r\n            if (v) out += `${childPad}${v}\\n`;\r\n        } else if (child.type === 'element') {\r\n            out += serializeElement(child, indent, depth + 1, preserveWS) + '\\n';\r\n        } else {\r\n            // comment, cdata, pi \u2014 preserve as-is, indented\r\n            const chunk = serializeNode(child, indent, depth + 1, preserveWS).trim();\r\n            if (chunk) out += `${childPad}${chunk}\\n`;\r\n        }\r\n    }\r\n    out += `${pad}</${tagName}>`;\r\n    return out;\r\n}\r\n\r\n// \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n/**\r\n * Returns true if the node list contains any element or has multi-line text\r\n * that indicates block-level content.\r\n */\r\nfunction hasBlockContent(nodes: HxmlNode[]): boolean {\r\n    for (const node of nodes) {\r\n        if (node.type === 'element' && !HTML_INLINE_ELEMENTS.has(node.name.toLowerCase())) return true;\r\n        if (node.type === 'text' && node.value.includes('\\n')) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/** Collapse leading/trailing whitespace in inline content. */\r\nfunction trimInline(s: string): string {\r\n    return s.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n}\r\n\r\n", "/**\r\n * index.ts \u2014 Public API for the HXML parser and compiler.\r\n *\r\n * Exports the main functions: parse, emit, validate, compile.\r\n */\r\n\r\nimport { parse as parseImpl, type ParseResult, type ParseOptions } from './parser.js';\r\nimport { emit as emitImpl, type EmitResult, type EmitOptions, type EmitMode } from './emitter.js';\r\nimport { validate as validateImpl } from './validator.js';\r\nimport { htmlToHxml as htmlToHxmlImpl, type ConvertOptions, type ConvertResult } from './converter.js';\r\nimport type { RootNode, HxmlNode, ElementNode, TextNode, CommentNode, CDataNode, ProcessingInstNode, DoctypeNode, ParsingMode, Attribute } from './ast.js';\r\nimport type { Diagnostic, DiagnosticSeverity } from './utils/errors.js';\r\nimport type { SourcePosition, SourceRange } from './utils/source-map.js';\r\n\r\n// \u2500\u2500 Re-exports \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport type {\r\n  // AST\r\n  RootNode, HxmlNode, ElementNode, TextNode, CommentNode, CDataNode,\r\n  ProcessingInstNode, DoctypeNode, ParsingMode, Attribute,\r\n  // Diagnostics\r\n  Diagnostic, DiagnosticSeverity,\r\n  // Source locations\r\n  SourcePosition, SourceRange,\r\n  // Options & results\r\n  ParseResult, ParseOptions,\r\n  EmitResult, EmitOptions, EmitMode,\r\n  ConvertOptions, ConvertResult,\r\n};\r\n\r\n// \u2500\u2500 Main API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\n/**\r\n * Parse an HXML source string into an AST.\r\n */\r\nexport function parse(source: string, options?: ParseOptions): ParseResult {\r\n  return parseImpl(source, options);\r\n}\r\n\r\n/**\r\n * Emit an HXML AST as HTML5.\r\n */\r\nexport function emit(ast: RootNode, options?: EmitOptions): EmitResult {\r\n  return emitImpl(ast, options);\r\n}\r\n\r\n/**\r\n * Validate an HXML AST and return diagnostics.\r\n */\r\nexport function validate(ast: RootNode): Diagnostic[] {\r\n  return validateImpl(ast);\r\n}\r\n\r\n/**\r\n * Convert an HTML5 source string into equivalent HXML source.\r\n *\r\n * Every HTML document is already valid HXML \u2014 this function adds explicit\r\n * closing tags, consistent indentation, and readies the document for\r\n * XML namespace extensions.\r\n */\r\nexport function htmlToHxml(source: string, options?: ConvertOptions): ConvertResult {\r\n  return htmlToHxmlImpl(source, options);\r\n}\r\n\r\n/**\r\n * Format an HXML source string with consistent indentation and explicit\r\n * closing tags. This is the canonical HXML formatter used by `hxml fmt`.\r\n *\r\n * Since HXML is a superset of HTML, this function accepts any valid HXML\r\n * document (including pure HTML) and returns properly formatted HXML.\r\n */\r\nexport function format(source: string, options?: ConvertOptions): ConvertResult {\r\n  return htmlToHxmlImpl(source, options);\r\n}\r\n\r\n// \u2500\u2500 Compile (convenience) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nexport interface CompileOptions {\r\n  parse?: ParseOptions;\r\n  emit?: EmitOptions;\r\n  /** If true, skip the validation pass. */\r\n  noValidate?: boolean;\r\n}\r\n\r\nexport interface CompileResult {\r\n  html: string;\r\n  ast: RootNode;\r\n  diagnostics: Diagnostic[];\r\n}\r\n\r\n/**\r\n * Compile HXML source to HTML5 in one step.\r\n * Chains: parse \u2192 validate \u2192 emit.\r\n */\r\nexport function compile(source: string, options?: CompileOptions): CompileResult {\r\n  const parseResult = parseImpl(source, options?.parse);\r\n  const diagnostics = [...parseResult.diagnostics];\r\n\r\n  if (!options?.noValidate) {\r\n    const validationDiags = validateImpl(parseResult.ast);\r\n    diagnostics.push(...validationDiags);\r\n  }\r\n\r\n  const emitResult = emitImpl(parseResult.ast, options?.emit);\r\n\r\n  return {\r\n    html: emitResult.html,\r\n    ast: parseResult.ast,\r\n    diagnostics,\r\n  };\r\n}\r\n"],
  "mappings": "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",
  "names": ["s", "val", "text", "name", "parse", "emit", "validate", "htmlToHxml"]
}
